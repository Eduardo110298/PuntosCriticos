ponerespacios :: String -> String                                                                                                 --Función ponerespacios: Función que se encarga de recibir una cadena y poner espacios donde consiga una coma.
ponerespacios [] = []
ponerespacios (x:xs) = if x==',' then ([x]++[' ']) ++ ponerespacios xs else [x] ++ ponerespacios xs

matrizespecial :: [String] -> Int -> Bool                                                                                         --Función matrizespecial: (Recibe las lineas del archivo, la cantidad de planetas y devuelve un booleano), Ésta función evalúa aquellos grafos que poseen la característica que personalmente defino como "Especial", y la misma no es más que el caso en donde todos los nodos están conectados con todos. Retorna un booleano indicando si la matriz es especial o no.
matrizespecial lista n = if lacantidaddeunos == n*n-n then True else False                                                        --La evaluación consiste en sumar todos los unos de la matriz y si la cantidad de unos es igual a n*n-1 (donde n es el cantidad de planetas), entonces la función se evalúa a Verdadero, sino a Falso. 
    where lacantidaddeunos = length ([x|x<-(unwords (tail lista)),x/=' ',x/='0'])                                                 --La cantidad de unos (O suma de todos los unos), la realizo extrayendo todos los unos e ingresandolos en una lista. El tamaño de ésa lista será la cantidad de unos. El cálculo se realiza de ésta manera porque los unos son almacenados como cadenas.

puntoscriticos :: [(Int,Int)] -> Int -> [Int] -> Int -> [Int] -> [Int]                                                            --Función puntoscriticos: (Recibe las aristas del grafo, la cantidad de planetas, una lista con las posiciones de los planetas (pues los planetas en todo momento se trabajan con sus posiciones (Ej. Planeta 0, Planeta 1 y asi...)), una bandera que me permite saber si ya he conseguido mis puntos para poder entrar al primer patrón y retornar, y la lista de puntos criticos a retornar (se manda vacía)).
puntoscriticos _ _ _ 0 criticos = criticos                                                                                        --El patrón que me permitirá retornar.
puntoscriticos aristas n codigos 1 criticos = if (puntos/=[]) then                                                                --Aquí evalúo si la lista de puntos críticos obtenidos no es vacía. En caso de serlo, procedo a ver si me retornó 1 punto crítico.
                                               if (length puntos==1) then
                                                puntoscriticos aristas n codigos 0 (criticos++puntos)                             --Si resulta que efectivamente el algoritmo me generó 1 punto crítico entonces realizo la llamada a puntoscriticos nuevamente pero con la bandera en 0 (para retornar) y a la lista que retorno (criticos), añado ése critico que se ha obtenido.
                                               else
                                                puntoscriticos aristas n codigos 0 (criticos++[mejor_candidato puntos 0 0 arbol]) --Si de lo contario, he obtenido varios puntos críticos, entonces realizo la llamada a puntos crítico con la bandera en 0 pero en vez de concatenar todos ésos puntos obtenidos, se concatena más bien lo que me devuelva la función mejor_candidato (a la que le mando los puntos obtenidos, dos valores iniciales para el cálculo del más critico y el árbol bfs que usará para saber cuál es el nodo más crítico).
                                              else
                                                puntoscriticos nuevasaristas (n-1) nuevoscodigos 1 (criticos++[sospechoso])       --Si resulta que el algoritmo no me ha generado puntos críticos (es decir, que la lista devuelta sea vacía), entonces vuelvo a llamar a la función puntos críticos pero con nuevos datos (Nuevasaristas: porque voy a eliminar un nodo que sea el que más conexiones tenga, (n-1): porque debo restarle 1 a la cantidad de nodos, nuevoscodigos: (son los nuevos planetas a revisar) se trata de la lista actualizada de planetas sin el recién borrado, la bandera en 1 para que ejecute el algoritmo en la proxima llamada y la lista de los criticos concatenadole el sospechoso que acabo de borrar).
    
    where p = fst (head aristas)                                                           --p es usado para el recorrido bfs, pues éste recorrido se realiza desde la que yo considere raiz de mi grafo (y yo considero raiz de mi grafo al primero de mis planetas). Ésta P se calcula porque no siempre mi primer planeta va a ser el 0, puede que haya elimminado el 0 y entonces deba ser el siguiente, y para busca ése "próximo primer planeta", extraigo con la función head a la que haya quedado como primera dupla y luego accedo a el primer elemento de esa tupla.
          puntos = algoritmo [] aristas codigos n                                          --puntos va a tener la lista que genere la función algoritmo. 
          arbol = fst (bfs aristas [p] [p] n [])                                           --arbol va a tener el primer elemento de la dupla que me genere la función bfs. Pues ésta función está diseñada para retornar una dupla cuya primera posición serán las aristas del arbol generado por el recorrido.
          nuevasaristas = [y|y<-aristas,(fst y)/=sospechoso,(snd y)/=sospechoso]           --nuevasaristas tendrá la lista de aristas eliminando cualquier aparición del nodo sospechoso que es detectado.
          sospechoso = mejor_candidato codigos 0 0 aristas                                 --sospechoso tendrá al mejor candidato a ser nodo crítico del grafo original.
          nuevoscodigos = [z|z<-codigos,z/=sospechoso]                                     --nuevoscodigos tendrá la lista de códigos de planetas actualizada sin el planeta que se está eliminando.

mejor_candidato :: [Int] -> Int -> Int -> [(Int,Int)] -> Int                                                                                                           --Función mejor_candidato: (Recibe una lista de planetas (Lista de enteros porque manejamos los planetas con claves enteras que indican su posición en la matriz), dos enteros para almacenar el planeta que posea la mayor cantidad de conexiones y para almacenar las conexiones que tendrá ese mayor, respectivamente; así como también la lista de aristas del grafo a analizar), devuelve un entero que me indica el planeta con más conexiones (es decir, el mejor candidato).
mejor_candidato [] mayor _ _ = mayor                                                                                                                                   --El patrón que me permitirá retornar al mejor candidato.
mejor_candidato (x:xs) mayor enlaces arbol = if (conexiones>enlaces) then mejor_candidato xs x (conexiones) arbol else mejor_candidato xs mayor enlaces arbol          --Evalúo si las conexiones (descritas en la proxima linea), son mayores que el número de enlaces que tiene actualmente el mayor. De ser cierto entonces éste nodo analizado (es decir: x), pasa a convertirse en el proximo mayor, y por lo tanto se realiza la llamada a la función nuevamente pasandole por parametro el resto de la lista de planetas que estoy analizando, los datos de ése mayor (planeta y conexiones) y las mismas aristas para que continúe haciendo el análisis.
    where conexiones = contar x ((map fst arbol)++(map snd arbol)) 0                                                                                                   --Conexiones posee la cantidad de conexiones que tiene ése planeta x que se está analizando actualmente. Para éso hace uso de la función contar (definida posteriormente), a la que le manda x y la lista en donde buscará las apariciones de esa x. Ésa lista no es mas que la que resulta de realizarle un mapeo para extraer tanto las primeras como segundas posiciones de mis duplas.

contar :: (Eq a) => a -> [a] -> Int -> Int                                                                                              --Función contar: (Recibe el elemento al que le analizará la aparición, la lista en donde trabajará y las apariciones que retornará (inicialmente éste valor es 0 porque no se ha contado nada)) se encarga de retornar la cantidad de apariciones de un elemento en una lista.
contar _ [] apariciones = apariciones                                                                                                   --El patrón que me permitirá retornar la cantidad de apariciones del elemento.
contar elemento (x:xs) apariciones = if (x==elemento) then contar elemento xs (apariciones+1) else contar elemento xs apariciones       --Si el elemento x de la lista es igual al elemento estudiado, se vuelve a realizar la llamada con el resto de la lista y las apariciones + 1. Sino, se llama la función con el resto de la lista pero sin incrementar las apariciones.

algoritmo :: [Int] -> [(Int,Int)] -> [Int] -> Int -> [Int]                                                                                                                           --Función algoritmo: (Recibe la lista de puntos criticos a devolver (mandada en []), la lista de aristas, la lista de planetas a analizar, la cantidad de planetas que hay en total). Devuelve la lista de puntos críticos que detecte. El algoritmo consiste en realizar un estudio sobre todos los nodos y uno por uno analizar qué sucede si realizo el recorrido bfs desde algún nodo hijo de ése que se está estudiando. Si ese recorrido me indica que se pudo llegar a todos los nodos, entonces quiere decir que el nodo en estudio no es un punto crítico del grafo; en caso contrario (que no se hayan recorrido todos los nodos) entonces se dice que ese nodo en estudio es un punto crítico.
algoritmo candidatos _ [] _ = candidatos                                                                                                                                             --El patrón que permite el retorno de los candidatos.
algoritmo candidatos aristas (y:ys) n = if (snd $ bfs aristas [hijo] ([y]++[hijo]) n []) then algoritmo candidatos aristas ys n else algoritmo (candidatos++[y]) aristas ys n        --La condición revisa el segundo elemento de la dupla que retorna la función bfs (pues éste es un booleano que indica si se recorrieron o no todos los nodos del grafo).
    where hijo = head ([snd z|z<-aristas, (fst z)==y])                                                                                                                               --hijo: se encarga de obtener un hijo de un nodo en estudio. Para éso se utiliza una comprensión que obtenga todas las aristas que corresponden al nodo en estudio (fst z == y), y a todas esas duplas obtenidas les extraigo el segundo elemento (snd z) pues éstos serán los hijos del nodo en estudio. Luego se extrae el primer elemento (head) de ésa lista de hijos.

transformar :: [(Int,Int)] ->  Int -> Int -> Int -> [[String]] -> [(Int,Int)]                                                           --Función transformar: (Recibe una lista de duplas (serás las duplas a devolver, y por eso de mandan incialmente en []), tres enteros (n:para saber cuánto he llegado al fin de la columna, i:índice para manejar la fila, j:índice para manejar la columna) y una lista de listas de cadenas (que contendrán la matriz)) Dado un grafo en forma de matriz de adyacencia, devuelve un grafo en forma de pares ordenados de aristas (devuelve una lista de tuplas)
transformar conexiones _ _ _ [] = conexiones                                                                                            --El patrón que permite el retorno de las conexiones (aristas del grafo en forma de Lista de duplas).
transformar conexiones n i j ((x:xs):ys)                                                                                                --La lógica de la función es simple: Si el elemento que se está estudiando (x), es un 0, entonces se llama la función para que estudie la otra posición de la matriz pero ignorando la conexión (pues si hay un 0, entonces en realidad no habria nada que guardar). Si la x es un 1 entonces se vuelve a llamar a la función pero considerando ésa fila y ésa columna como una dupla a ingresar en mi lista a devolver.
    | x == "0" = if (j==n) then transformar conexiones n (i+1) 0 ys else transformar conexiones n i (j+1) (xs:ys)                       --En ambos casos se verifica si  j==n, pues ésto indicará cuándo se llega a la última columna (y ésto es importante saberlo para ver si la llamada debe realizarse con el mismo i, con la (j+1) y (xs:ys) (que son el resto de las columnas con el resto de las filas); o si hay que realizar la llamada con (i+1), con j=0 y con ys (que posee el resto de mis filas))
    | x == "1" = if (j==n) then transformar (conexiones++[(i,j)]) n (i+1) 0 ys else transformar (conexiones++[(i,j)]) n i (j+1) (xs:ys)

bfs :: [(Int,Int)] -> [Int] -> [Int] -> Int -> [(Int,Int)] -> ([(Int,Int)],Bool)                                                        --Función bfs: (Recibe el grafo en forma de aristas, una lista de enteros que será la cola, otra lista de enteros que serán los nodos visitados, un entero que corresponde a la cantidad de nodos en total (útil para retornar el segundo valor de la dupla) y una lista de duplas de entero que será el árbol que se va a devolver (inicialmente con el valor de [])), retorna una dupla que en la primera posición posee el árbol generado por el recorrido bfs y en la segunda posición un booleano que será verdadero si se han recorrido todos los nodos y falso en caso contrario.
bfs [] _ visitados n arbol = bfs [(0,0)] [] visitados n arbol                                                                           --Un patrón que si se cumple, simplemente da pie al siguiente patrón que es el que corresponde al retorno de la función.
bfs _ [] visitados n arbol = (arbol,(length visitados)== n)                                                                             --El patrón que permite el retorno de la función.
bfs (x:xs) (y:ys) visitados n arbol
    | (fst x) == y = if ((snd x) `elem` visitados) then bfs xs (y:ys) visitados n arbol else bfs xs ((y:ys)++[snd x]) (visitados++[snd x]) n (arbol++[x]) --La lógica es simple: Se realiza un recorrido de la lista de duplas (aristas del grafo), y la cola también se analiza (pues ésta indicará el fin del recorrido). 'y' es la cabeza de la cola y por consiguiente, el recorrido consiste en ir revisando si el primer elemento de la tupla en la que estoy parado es igual a la cabeza de mi cola (pues es ése el nodo al que le estoy revisando los hijos). Si es así, entonces estoy parado en una tupla a la que le tengo que revisar el nodo con el que está conectado (snd x) y ver si éste ya fue visitado. Si ya fue visitado, ignoro ésa conexión, sino fue visitado entonces concateno ésa conexion al árbol que se devolverá.
    | (fst x) /= y = if (y `elem` (map fst xs)) then bfs (xs++[x]) (y:ys) visitados n arbol else bfs (x:xs) ys visitados n arbol                          --Si resulta que la tupla en revisada (x) no corresponde al elemento en la cabeza de la cola, entonces debo revisar si ése nodo (y) existe en las tuplas restantes (es decir, si aún quedan conexiones que involucren a y) y en caso de ser asi, entonces simplemente se vuelve a llamar la función pero con la lista de tuplas modificada (mando al elemento que no correspondía al final) para poder seguir revisando las conexiones que tenga 'y'. Si 'y' no aparece en ningún lugar entonces la desencolo totalmente para visitar al proximo nodo.

main = do --La función principal.
    lineas <- readFile "MAPA.TXT"
    let lista = lines lineas                                                                                                                --Lectura de todas las lineas del archivo: La función lines detecta los saltos de linea y con éso puede almacenar todas las lineas del archivo en una lista de String que contendrá todas las lineas separadas.
        planetas = words [x|x<-(ponerespacios (init $ tail $ head lista)),x/=',']                                                           --Guardado de los nombres de los planetas: En ésta linea es posible apreciar que se realiza en primer lugar una extracción de la cabeza de la lista anterior (la que posee todas las lineas del archivo) y ésta cabeza (o primer elemento de la lista) contendrá los nombres de los planetas. Éste elemento extraído es un String (pues la lista anterior almacena todo en una lista de String), y éste puede ser tratado a su vez como una lista de Char. Cuya lista posee en su primera posicion un '[', y en su última posición, un ']' y por esa razón se extrae primero la cola(tail) de esa lista (así ignoro el primer corchete), y luego se usa el init para ignorar el último corchete. Luego se obtendrá una lista de Char con los nombres de los planetas separados por "," y por espacios, por esa razón se usa una lista por comprensión que ignore esas "," y finalmente con mis nombres separados por espacios, se aplica la función words que toma una cadena con palabras separadas por espacios y devuelve una lista de String con todas la palabras.
        matriz = [words x|x<-tail lista]                                                                                                    --Guardado de la matriz: Si en la cabeza de mi lista (la de las lineas del archivo), están almacenados los nombres de los planetas, entonces lógicamente el resto de la lista (tail), contendrá las lineas que corresponden a la matriz de adyacencia del grafo. Y a todas esos elementos les aplico la función words para separar en Listas de String todos los ceros y unos.
        cantplanetas = length planetas                                                                                                      --Conteo de la cantidad de planetas existentes: Simplemente devuelve la longitud de la lista que contiene los planetas.
        planetascod = [0..cantplanetas-1]                                                                                                   --Obtención de una lista con los codigos de los planetas: Los planetas tienen una posición asociada y es más cómodo trabajar con ésa posición que con el nombre del planeta.
        aristas = transformar [] (cantplanetas-1) 0 0 matriz                                                                                --Transformación de la matriz de adyacencia a lista de aristas: En realidad no se transforma la matriz, sino que más bien se consigue el equivalente de ésa matriz de adyacencia y se traduce a una lista de aristas
        criticos = if (matrizespecial lista cantplanetas) then [head planetascod] else puntoscriticos aristas cantplanetas planetascod 1 [] --Aquí se realiza la asignación de la lista de críticos a 'criticos', pero se evalúa antes si la matriz de ese grafo es especial (para reaccionar de la forma correcta), si no es una matriz especial entonces simplemente se llama a la función puntoscriticos, que constituye la función que realiza el trabajo, haciendo uso de las demás herramientas.
    writeFile "CRITICOS.TXT" (ponerespacios ([x|x<- (show [planetas!!x|x<-criticos]),x/='"']))                                              --Escritura de la linea en el archivo CRITICOS.TXT
    return () --Realizdo por Eduardo Manuel Rodríguez Lara. C.I. 26.082.457